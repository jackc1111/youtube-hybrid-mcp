import { spawn } from 'child_process';
import { readFileSync, unlinkSync, existsSync } from 'fs';
import { tmpdir } from 'os';
import { join } from 'path';

export interface SubtitleResult {
  videoId: string;
  language: string;
  available: boolean;
  message?: string;
  availableLanguages?: string[];
  transcript?: TranscriptItem[];
  vttContent?: string;
  fileName?: string;
}

export interface TranscriptItem {
  text: string;
  duration: number;
  offset: number;
  endTime: number;
  startTimeFormatted: string;
  endTimeFormatted: string;
}

export interface SubtitleAvailability {
  hasSubtitles: boolean;
  availableLanguages: string[];
  isAutoGenerated?: boolean;
}

export interface SubtitleOptions {
  videoId: string;
  language?: string;
  saveToFile?: boolean;
  maxRetries?: number;
  retryDelay?: number;
  preferAutoGenerated?: boolean;
}

export class SubtitleAgent {
  private readonly DEFAULT_LANGUAGE = 'en';
  private readonly DEFAULT_MAX_RETRIES = 3;
  private readonly DEFAULT_RETRY_DELAY = 2000;
  private readonly SUBTITLE_FORMATS = ['vtt', 'srv3', 'srv2', 'srv1', 'json3'];
  private readonly HTTP_429_REGEX = /HTTP Error 429|Too Many Requests|rate limit/i;

  private options: Required<SubtitleOptions>;

  constructor(options: SubtitleOptions) {
    this.options = {
      language: options.language || this.DEFAULT_LANGUAGE,
      saveToFile: options.saveToFile || false,
      maxRetries: options.maxRetries || this.DEFAULT_MAX_RETRIES,
      retryDelay: options.retryDelay || this.DEFAULT_RETRY_DELAY,
      preferAutoGenerated: options.preferAutoGenerated ?? false,
      videoId: options.videoId
    };
  }

  async getSubtitles(): Promise<SubtitleResult> {
    const { videoId, language } = this.options;

    try {
      const availability = await this.checkSubtitlesAvailability();

      if (!availability.hasSubtitles) {
        return {
          videoId,
          language,
          available: false,
          message: 'No subtitles available for this video',
          availableLanguages: availability.availableLanguages
        };
      }

      const tempBase = join(tmpdir(), `subs_${videoId}_${Date.now()}`);
      
      for (const format of this.SUBTITLE_FORMATS) {
        try {
          const result = await this.downloadWithRetry(tempBase, format);
          await this.cleanup(tempBase, format);
          return result;
        } catch (error) {
          if (format === this.SUBTITLE_FORMATS[this.SUBTITLE_FORMATS.length - 1]) {
            throw error;
          }
          continue;
        }
      }

      throw new Error('Failed to download subtitles in any format');
    } catch (error) {
      return {
        videoId,
        language,
        available: false,
        message: `Error getting subtitles: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  private async checkSubtitlesAvailability(): Promise<SubtitleAvailability> {
    return new Promise((resolve) => {
      const ytDlp = spawn('yt-dlp', [
        '--list-subs',
        `https://www.youtube.com/watch?v=${this.options.videoId}`
      ]);

      let output = '';
      let errorOutput = '';

      ytDlp.stdout.on('data', (data) => {
        output += data.toString();
      });

      ytDlp.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      ytDlp.on('close', (code) => {
        if (code === 0) {
          const parsed = this.parseSubtitleList(output);
          resolve(parsed);
        } else {
          resolve({
            hasSubtitles: false,
            availableLanguages: []
          });
        }
      });

      ytDlp.on('error', () => {
        resolve({
          hasSubtitles: false,
          availableLanguages: []
        });
      });
    });
  }

  private parseSubtitleList(output: string): SubtitleAvailability {
    const lines = output.split('\n');
    const availableLanguages: string[] = [];
    const autoGeneratedLanguages: string[] = [];

    let inSubsSection = false;
    let inCaptionsSection = false;

    for (const line of lines) {
      if (line.includes('Available subtitles')) {
        inSubsSection = true;
        inCaptionsSection = false;
        continue;
      }
      if (line.includes('Available automatic captions')) {
        inCaptionsSection = true;
        inSubsSection = false;
        continue;
      }
      if ((inSubsSection || inCaptionsSection) && line.trim() === '') {
        break;
      }
      if (inSubsSection && line.includes(':')) {
        const lang = line.split(/\s+/)[0].trim();
        if (lang && lang !== 'Language' && lang !== 'Name' && lang.length === 2) {
          availableLanguages.push(lang);
        }
      }
      if (inCaptionsSection && !line.includes('Available') && line.trim() && !line.includes('Language')) {
        const lang = line.split(/\s+/)[0].trim();
        if (lang && lang.length >= 2 && lang.length <= 5) {
          autoGeneratedLanguages.push(lang);
        }
      }
    }

    const hasManual = availableLanguages.includes(this.options.language);
    const hasAuto = autoGeneratedLanguages.includes(this.options.language);

    let finalLanguages = [...new Set([...availableLanguages, ...autoGeneratedLanguages])];
    let hasSubtitles = false;
    let isAutoGenerated = false;

    if (this.options.preferAutoGenerated) {
      hasSubtitles = hasAuto;
      isAutoGenerated = hasAuto;
    } else {
      hasSubtitles = hasManual;
      isAutoGenerated = !hasManual && hasAuto;
    }

    if (!hasSubtitles) {
      hasSubtitles = hasManual || hasAuto;
      isAutoGenerated = !hasManual && hasAuto;
    }

    return {
      hasSubtitles,
      availableLanguages: finalLanguages,
      isAutoGenerated
    };
  }

  private async downloadWithRetry(tempBase: string, format: string): Promise<SubtitleResult> {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= this.options.maxRetries; attempt++) {
      try {
        await this.downloadSubtitles(tempBase, format);
        const vttFile = this.findSubtitleFile(tempBase);
        
        if (!vttFile) {
          throw new Error(`Subtitle file not found after download (tried base: ${tempBase})`);
        }

        const vttContent = readFileSync(vttFile, 'utf-8');
        unlinkSync(vttFile);

        const transcript = this.parseVTT(vttContent);
        let generatedVttContent = '';

        if (this.options.saveToFile && transcript.length > 0) {
          generatedVttContent = this.generateVTTContent(transcript);
        }

        const result: SubtitleResult = {
          videoId: this.options.videoId,
          language: this.options.language,
          available: true,
          transcript
        };

        if (this.options.saveToFile) {
          result.vttContent = generatedVttContent;
          result.fileName = `${this.options.videoId}_${this.options.language}.vtt`;
        }

        return result;
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));

        if (this.shouldRetry(error, attempt)) {
          const delay = this.options.retryDelay * attempt;
          await this.sleep(delay);
          continue;
        }

        throw lastError;
      }
    }

    throw lastError || new Error('Unknown error during subtitle download');
  }

  private async downloadSubtitles(tempBase: string, format: string): Promise<void> {
    const args = this.buildYtDlpArgs(tempBase, format);

    return new Promise((resolve, reject) => {
      const ytDlp = spawn('yt-dlp', args);

      ytDlp.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`yt-dlp failed with code ${code}`));
        }
      });

      ytDlp.on('error', reject);
    });
  }

  private buildYtDlpArgs(tempBase: string, format: string): string[] {
    const args = [
      '--write-subs',
      '--write-auto-subs',
      '--sub-langs', this.options.language,
      '--sub-format', format,
      '--skip-download',
      '--ignore-errors',
      '--no-warnings',
      '-o', tempBase,
      `https://www.youtube.com/watch?v=${this.options.videoId}`
    ];

    return args;
  }

  private findSubtitleFile(tempBase: string): string | null {
    const possibleExtensions = [
      `.${this.options.language}.vtt`,
      `.${this.options.language}.${this.SUBTITLE_FORMATS[0]}`,
      '.en.vtt',
      '.vtt'
    ];

    for (const ext of possibleExtensions) {
      const path = `${tempBase}${ext}`;
      try {
        if (existsSync(path) && readFileSync(path)) {
          return path;
        }
      } catch {
        continue;
      }
    }

    return null;
  }

  private shouldRetry(error: unknown, attempt: number): boolean {
    if (attempt >= this.options.maxRetries) {
      return false;
    }

    const errorMessage = error instanceof Error ? error.message : String(error);

    if (this.HTTP_429_REGEX.test(errorMessage)) {
      return true;
    }

    if (errorMessage.includes('ECONNRESET') ||
        errorMessage.includes('ETIMEDOUT') ||
        errorMessage.includes('ENOTFOUND') ||
        errorMessage.includes('ECONNREFUSED')) {
      return true;
    }

    return false;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private cleanup(tempBase: string, format: string): void {
    const possibleExtensions = [
      `.${this.options.language}.${format}`,
      `.${this.options.language}.vtt`,
      '.en.vtt',
      '.vtt'
    ];

    for (const ext of possibleExtensions) {
      const path = `${tempBase}${ext}`;
      try {
        if (existsSync(path)) {
          unlinkSync(path);
        }
      } catch {
        continue;
      }
    }
  }

  private parseVTT(vttContent: string): TranscriptItem[] {
    const lines = vttContent.split('\n');
    const transcript: TranscriptItem[] = [];
    let currentItem: TranscriptItem | null = null;

    for (const line of lines) {
      if (line.includes('-->')) {
        if (currentItem) {
          transcript.push(currentItem);
        }
        const [start, end] = line.split(' --> ');
        const startTime = this.timeToSeconds(start);
        const endTime = this.timeToSeconds(end);
        const duration = endTime - startTime;
        const offset = startTime * 1000;
        const endOffset = endTime * 1000;

        currentItem = {
          text: '',
          duration,
          offset,
          endTime: endOffset,
          startTimeFormatted: this.formatTime(offset),
          endTimeFormatted: this.formatTime(endOffset)
        };
      } else if (currentItem && line.trim() && !line.startsWith('WEBVTT') && !line.match(/^\d+$/)) {
        currentItem.text += line + ' ';
      }
    }

    if (currentItem) {
      transcript.push(currentItem);
    }

    return transcript;
  }

  private timeToSeconds(time: string): number {
    const parts = time.split(':');
    const hours = parseInt(parts[0]) || 0;
    const minutes = parseInt(parts[1]) || 0;
    const seconds = parseFloat(parts[2]) || 0;
    return hours * 3600 + minutes * 60 + seconds;
  }

  private formatTime(milliseconds: number): string {
    const totalSeconds = Math.floor(milliseconds / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    const ms = Math.floor(milliseconds % 1000);

    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    } else {
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    }
  }

  private generateVTTContent(transcript: TranscriptItem[]): string {
    let vttContent = 'WEBVTT\n\n';

    transcript.forEach((item, index) => {
      const startTime = this.formatVTTTime(item.offset);
      const endTime = this.formatVTTTime(item.endTime);

      vttContent += `${index + 1}\n`;
      vttContent += `${startTime} --> ${endTime}\n`;
      vttContent += `${item.text.trim()}\n\n`;
    });

    return vttContent;
  }

  private formatVTTTime(milliseconds: number): string {
    const totalSeconds = Math.floor(milliseconds / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    const ms = Math.floor(milliseconds % 1000);

    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
  }
}
